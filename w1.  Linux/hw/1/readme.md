
**Упражнение 1**

Напишите программу (на языке C), которая вызывает fork () в цикле 3 раза и спит ( sleep(..) ) 5 секунд. Запустите программу в фоновом режиме и запустите команду pstree несколько раз. Посмотрите на вывод и скажите, сколько процессов создано. Объясните результат. Измените программу так, чтобы она вызывала fork () 5 раз. Посмотрите, как меняется результат. Загрузите код в github/moodle.



**Отчёт о выполнении**

Для выполнения первой части задания была напсиана программа   fork3.c. Результат кмопиляции и работы программы содержатся в ex1.log (получен с помощью метода scrypt). Заметно, что вызов  
fork 3 раза вызвал создание 8 fork процессов (8 = 2^3). Связано это с тем, что процесс после системного вызова fork, раздваивается, у исходного процесса создаётся идентичный потомок-двойник . Создавшийся процесс будет занят выполнением того же кода ровно с той же точки, что и исходный процесс. С этим же связаны итоги работы модифицированной программы fork5.c, работа которой привела к вызову 32  fork  процессов. Последовательный вызов fork() приводит к тому, что каждый последующий вызов выполняется как в родительском, так и в дочернем процессе - количество процессов при последовательном вызове этого метода растёт со скоростью 2^n, где n - количество вызовов  fork.
